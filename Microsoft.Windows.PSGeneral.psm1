function Test-RebootPending {
    $OriginalEAP = $ErrorActionPreference
    $ErrorActionPreference = "SilentlyContinue"
    $RebootPending = $false

    if ((Get-ItemPropertyValue -Path "HKLM:\SOFTWARE\Microsoft\Updates" -Name "UpdateExeVolatile") -gt 0) {
        Write-PSFMessage -Level Verbose -Message "UpdateExeVolatile"
        $RebootPending = $true
    }

    if ((Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "PendingFileRenameOperations") -or
        (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "PendingFileRenameOperations2")) {

        Write-PSFMessage -Level Verbose -Message "PendingFileRenameOperations\PendingFileRenameOperations2"
        $RebootPending = $true
    }

    if (Test-Path -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") {
        Write-PSFMessage -Level Verbose -Message "WindowsUpdate"
        $RebootPending = $true
    }

    if ($null -ne (Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Services\Pending")) {
        Write-PSFMessage -Level Verbose -Message "WindowsUpdate"
        $RebootPending = $true
    }

    if (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" -Name "DVDRebootSignal") {
        Write-PSFMessage -Level Verbose -Message "DVDRebootSignal"
        $RebootPending = $true
    }
    
    if ((Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") -or
        (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootInProgress") -or
        (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\PackagesPending")) {
        Write-PSFMessage -Level Verbose -Message "Component Based Servicing"
        $RebootPending = $true
    }

    if (Test-Path -Path "HKLM:\SOFTWARE\Microsoft\ServerManager\CurrentRebootAttempts") {
        Write-PSFMessage -Level Verbose -Message "ServerManager"
        $RebootPending = $true
    }

    if ($null -ne (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon" -Name "JoinDomain") -or
        $null -ne (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon" -Name "AvoidSpnSet")) {
        Write-PSFMessage -Level Verbose -Message "Netlogon"
        $RebootPending = $true
    }

    if ((Get-ItemPropertyValue -Path "HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName" -Name "ComputerName") -ne
    (Get-ItemPropertyValue -Path "HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName" -Name "ComputerName")) {
        Write-PSFMessage -Level Verbose -Message "ComputerName"
        $RebootPending = $true
    }

    $ErrorActionPreference = $OriginalEAP
    return $RebootPending
}

<#
.DESCRIPTION
Changes the size of the Windows Recovery partition (in bytes).
This is done by shrinking the OS drive then deleting/creating the WinRE partition.
#>
function Resize-WinREPartition {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateRange(524288000, [UInt64]::MaxValue)] # Making a WinRE partition under 500 MB is probably a bad idea
        [UInt64]
        $NewSize,
        [Parameter(Mandatory = $false)]
        [bool]
        $Confirm = $true
    )

    # Perform some checks before continuing
    $SysDisk = Get-Disk -Path ((Get-Partition | Where-Object { $_.Type -eq "System" }).DiskPath)
    # Although we could work on MBR disks, we're only supporting GPT
    if ($SysDisk.PartitionStyle -ne "GPT") { Write-PSFMessage -Level Critical -Message "Disk is not GPT."; return $false }

    $WinREPart = Get-Partition -DiskNumber $SysDisk.Number | Where-Object { $_.Type -eq "Recovery" }
    # Would need original install media
    if (-not ($WinREPart)) {
        Write-PSFMessage -Level Critical -Message "Unable to find the Windows Recovery partition."
        return $false
    }

    $WinREDOSPath = Get-WinRELocation
    # We can't assign a drive letter to the WinRE partition
    if (-not $WinREDOSPath) {
        Write-PSFMessage -Level Critical -Message "Failed to detect the Windows RE location."
        return $false
    }
    else {
        $WinREDOSPath = "$WinREDOSPath\Winre.wim"
        # Make sure the WinRE image can fit
        try {
            # After a WinRE partition is created, a couple extra files are too
            # Don't let the user cut it too close, give an extra 10 MB of room
            $WinREOverBy = $NewSize - ((Get-ChildItem -LiteralPath $WinREDOSPath -Hidden -ErrorAction Stop).Length + 10485760)
            if ($WinREOverBy -lt 0) {
                Write-PSFMessage -Level Error -Message "The new size is not big enough to fit the WinRE image: $($WinREOverBy * -1) additional bytes needed."
                return $false
            }
        }
        catch {
            Write-PSFMessage -Level Critical -Message "Failed to get the size of the WinRE image: $_"
            return $false
        }
    }

    # Calculate space needed
    $OSPart = Get-Partition -DriveLetter $env:SystemDrive[0]
    $OSPartNewSize = -1
    $WinRESizeNeeded = $NewSize - $WinREPart.Size
    if ($WinRESizeNeeded -eq 0) {
        Write-PSFMessage -Level Error -Message "The new size cannot be the same as the current size."
        return $false
    }
    elseif ($WinRESizeNeeded -gt 0) {
        # Depending on the computer, this operation could take a bit (could use try/catch and skip Get-PartitionSupportedSize)
        $OSPartSizeMin = ($OSPart | Get-PartitionSupportedSize).SizeMin
        $OSPartNewSize = $OSPart.Size - $WinRESizeNeeded
        if ($OSPartNewSize -lt $OSPartSizeMin) {
            $OverBy = $OSPartSizeMin - $OSPartNewSize
            $msg = "Drive $($OSPart.DriveLetter):\ cannot be shrunk by that much: $OverBy bytes over the limit."

            Write-PSFMessage -Level Error -Message $msg
            return $false
        }
    }
    else {
        $OSPartNewSize = $OSPart.Size + $WinRESizeNeeded * -1
    }

    # Notify the user that this is a DESTRUCTIVE act. If something goes wrong, the user is without a WinRE partition.
    if ($Confirm) {
        $ConfirmPrompt = "This will DELETE the Windows Recovery partition, in order to resize it."
        Write-PSFMessage -Level Warning -Message $ConfirmPrompt
        if ((Read-Host -Prompt "Continue? (y/n) [n]").ToLower() -ne "y") {
            Write-PSFMessage -Level Host -Message "Resize operation cancelled."
            return $false
        }
    }

    # Proceed with operation
    $ErrorActionPreference = 'Stop'

    # Backup the existing .wim file
    # If we don't back this up, we need the install media
    try {
        Get-ChildItem -LiteralPath $WinREDOSPath -Hidden | Copy-Item -Destination "$env:SystemRoot\System32\Recovery" -Force
        # Be absolutely certain we copied it
        [void](Get-ChildItem -Path "$env:SystemRoot\System32\Recovery\Winre.wim" -Hidden)
    }
    catch {
        Write-PSFMessage -Level Critical -Message "Failed to copy Winre.wim: $_"
        return $false
    }

    # ReAgent.xml doesn't update after initially generated; will cause failure unless deleted
    if (Test-Path -Path "$env:SystemRoot\System32\Recovery\ReAgent.xml" -ErrorAction SilentlyContinue) {
        try {
            Remove-Item -Path "$env:SystemRoot\System32\Recovery\ReAgent.xml"
        }
        catch {
            Write-PSFMessage -Level Critical -Message "Failed to delete ReAgent.xml: $_"
            return $false
        }
    }
    
    ### DESTRUCTIVE ACTION BEGINS HERE ###
    # Must be done in this order; otherwise, space will be "out of order"
    # Shrink OS drive
    if ($WinRESizeNeeded -gt 0) {
        [void]($OSPart | Resize-Partition -Size $OSPartNewSize)
        [void]($WinREPart | Remove-Partition -Confirm:$false)
    }
    # Expand OS drive
    else {
        [void]($WinREPart | Remove-Partition -Confirm:$false)
        [void]($OSPart | Resize-Partition -Size $OSPartNewSize)
    }

    $WinREPart = New-Partition -DiskNumber $SysDisk.Number -GptType "{de94bba4-06d1-4d40-a16a-bfd50179d6ac}" -Size $NewSize
    [void](Get-Volume -Path ($WinREPart.AccessPaths | Select-Object -First 1) | Format-Volume -FileSystem NTFS -NewFileSystemLabel "Recovery")

    # No way to get the end of the attributes value to '1' without Diskpart
    # Believe it sets 'Required' to 'Yes'
    # https://gist.github.com/mt7479/814e2a114d15e5bc7d64b8f2f89b7128
    $DiskpartScriptPath = "$env:TEMP\DiskpartSetGptAttr.txt"
    @"
select disk $($WinREPart.DiskNumber)
select partition $($WinREPart.PartitionNumber)
gpt attributes=0x8000000000000001
"@ | Set-Content -Path $DiskpartScriptPath
    $DiskpartResult = Start-Process -FilePath "diskpart.exe" -ArgumentList @("/s", $DiskpartScriptPath) -WindowStyle Hidden -PassThru -Wait
    if ($DiskpartResult.ExitCode -eq 0) {
        $ReagentcEnableResult = Invoke-ReAgentC -ArgumentList @("/enable")
        # reagentc can return a successful looking message despite not actually enabling WinRE.
        if ($ReagentcEnableResult -match "Operation Successful") {
            if (-not ((Invoke-ReAgentC -ArgumentList @("/info")) -match "Windows\sRE\sstatus:\s+Enabled")) {
                Write-PSFMessage -Level Critical -Message "The Windows RE status is 'disabled' despite successful enable operation."
            }
            else {
                return $true
            }
        }
        else {
            Write-PSFMessage -Level Critical -Message "Windows RE failed to enable: $($ReagentcEnableResult)"
        }
    }
    else {
        Write-PSFMessage -Level Critical -Message "Diskpart failed to set GPT attributes: Exit code $($DiskpartResult.ExitCode)"
    }

    return $false
}

function Optimize-DismImage {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [String]
        $Path
    )
  
    if ((Test-Path -Path $Path) -eq $false) { Write-PSFMessage -Level Error -Message "The specified path does not exist."; return $false }
  
    Write-PSFMessage -Level Verbose -Message "Running DISM Cleanup-Image"
    $DISMCleanupResult = dism /image:$Path /cleanup-image /StartComponentCleanup /ResetBase 
    if ($DISMCleanupResult -Match "The operation completed successfully.") { Write-PSFMessage -Level Verbose -Message "DISM Cleanup-Image Successful"; return $true }
    else { Write-PSFMessage -Level Critical -Message "DISM Cleanup-Image Failed. Output: $DISMCleanupResult"; return $false }
}
  
function Add-DismPackage {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [String]
        $Path,
        [Parameter(Mandatory = $true)]
        [ref]
        $Output,
        [Parameter(Mandatory = $true)]
        [String]
        $PackagePath
    )
  
    begin {
        if ((Test-Path -Path $Path) -eq $false) { Write-PSFMessage -Level Error -Message "The specified path does not exist."; return $false }
    }
    process {
        $Output.Value = Dism /Add-Package /Image:$Path /PackagePath:$PackagePath
        if ($Output.Value -Match "The operation completed successfully.") { Write-PSFMessage -Level Verbose -Message "DISM Add-Package Successful"; return $true }
        # x800f0823 could indicate a temporary error. Wait and try again.
        else { Write-PSFMessage -Level Critical -Message "DISM Add-Package Failed. Output: $($Output.Value)"; return $false }
    }
}
  
function Get-WinREMountPath {
    if (((& dism /get-mountedimageinfo) -join "`n") -match "Mount\sDir\s:\s+(?<MountDir>.+)\n.+\\\\\?\\GLOBALROOT\\device\\.+\\Recovery\\WindowsRE\\winre.wim") {
        return $Matches["MountDir"].Trim()
    }
  
    return $null
}

function Get-WinRELocation {
    if (((Invoke-ReAgentC -ArgumentList @("/info")) |
            Select-String "Windows\sRE\slocation:\s+(?<WinRELocation>.+)") -match "Windows\sRE\slocation:\s+(?<WinRELocation>.+)") {
        return $Matches["WinRELocation"].Trim()
    }
    
    return $null
}

function Get-WinREImageInfo {
    $WinRELocation = (Get-WinRELocation) + "\Winre.wim"
    return Get-WindowsImage -imagepath $WinRELocation -index 1
}
  
function Mount-WinRE {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [String]
        $Path = "$env:TEMP\WinRE"
    )
  
    begin {
        # Create mount directory if it doesn't exist
        if (!(Test-Path -PathType Container -Path $Path)) { New-Item -ItemType Directory -Path $Path -Force | Out-Null }
    }
    process {
        Write-PSFMessage -Level Verbose -Message "Mounting Windows RE"
        $REMountResult = Invoke-ReAgentC -ArgumentList @("/mountre", "/path", $Path) -WaitForExit 300 # 5 minutes
        # Return the path of the mount on success
        if ($REMountResult -Match "Operation Successful.") { Write-PSFMessage -Level Verbose -Message "Mounting Windows RE Successful"; return $Path }
        else { Write-PSFMessage -Level Critical -Message "Mounting Windows RE Image Failed. Output: $REMountResult"; return $null }
    }
}
  
function Dismount-WinRE {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [String]
        $Path,
        [Parameter(Mandatory = $true)]
        [ref]
        $Output,
        [Parameter(Mandatory = $false)]
        [Switch]
        $NoCommit
    )
  
    begin {
        if ((Test-Path -Path $Path) -eq $false) { Write-PSFMessage -Level Error -Message "The specified path does not exist."; return $false }
    }
    process {
        if ($NoCommit) {
            Write-PSFMessage -Level Verbose -Message "Dismounting and discarding changes"
            $Output.Value = Invoke-ReAgentC -ArgumentList @("/unmountre", "/path", $Path, "/discard") -WaitForExit 300 # 5 minutes
        }
        else {
            # Can result in error code 70 (not enough space)
            # Error codes map to HEX not INT: https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
            Write-PSFMessage -Level Verbose -Message "Dismounting and saving changes"
            $Output.Value = Invoke-ReAgentC -ArgumentList @("/unmountre", "/path", $Path, "/commit") -WaitForExit 600 # 10 minutes
        }

        Write-PSFMessage -Level Verbose -Message $Output.Value
    
        if ($Output.Value -Match "Operation Successful.") { return $true }
        else { Write-PSFMessage -Level Critical -Message "Dismounting failed: $($Output.Value)"; return $false }
    }
}

# This is to capture STDERR
function Invoke-ReAgentC {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [String[]]
        $ArgumentList,
        [Parameter(Mandatory = $false)]
        [int]
        $WaitForExit = 120 # Seconds
    )

    $RCPSI = [System.Diagnostics.ProcessStartInfo]::new("ReAgentC.exe", ($ArgumentList -join " "))
    $RCPSI.CreateNoWindow = $true
    $RCPSI.UseShellExecute = $false 
    $RCPSI.RedirectStandardOutput = $true
    $RCPSI.RedirectStandardError = $true

    $RCP = [System.Diagnostics.Process]::new()
    $RCP.StartInfo = $RCPSI
    [void]($RCP.Start())
    [void]($RCP.WaitForExit($WaitForExit * 1000))

    return "$($RCP.StandardOutput.ReadToEnd())`n$($RCP.StandardError.ReadToEnd())"
}